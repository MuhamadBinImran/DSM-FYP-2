import { useEffect, useRef } from 'react';

const useWowAnimation = (config = {}) => {
  const defaultConfig = {
    boxClass: 'wow',
    animateClass: 'animated',
    offset: 0,
    mobile: true,
    live: true,
    callback: null,
    scrollContainer: null,
  };

  const mergedConfig = { ...defaultConfig, ...config };
  const animationNameCache = useRef(new Map());
  const boxes = useRef([]);
  const scrolled = useRef(false);
  const interval = useRef(null);

  const util = {
    isMobile: (userAgent) => {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
    },

    createEvent: (name) => {
      if (typeof window === 'undefined') return null;
      if (typeof(CustomEvent) === 'function') {
        return new CustomEvent(name);
      } else {
        const event = document.createEvent('CustomEvent');
        event.initCustomEvent(name, true, true, null);
        return event;
      }
    },

    addEvent: (element, eventName, callback) => {
      if (element.addEventListener) {
        element.addEventListener(eventName, callback, false);
      } else if (element.attachEvent) {
        element.attachEvent('on' + eventName, callback);
      }
    },

    removeEvent: (element, eventName, callback) => {
      if (element.removeEventListener) {
        element.removeEventListener(eventName, callback, false);
      } else if (element.detachEvent) {
        element.detachEvent('on' + eventName, callback);
      }
    },

    innerHeight: () => {
      if (typeof window === 'undefined') return 0;
      return window.innerHeight || document.documentElement.clientHeight;
    },
  };

  const isVisible = (box) => {
    if (typeof window === 'undefined') return false;
    
    const offset = box.getAttribute('data-wow-offset') || mergedConfig.offset;
    const boxTop = ((ref) => {
      const bodyRect = document.body.getBoundingClientRect();
      const elemRect = ref.getBoundingClientRect();
      return elemRect.top - bodyRect.top;
    })(box);
    
    const viewTop = (
      (mergedConfig.scrollContainer && mergedConfig.scrollContainer.scrollTop) || 
      window.pageYOffset
    );
    const viewBottom = viewTop + Math.min(
      document.documentElement.clientHeight,
      util.innerHeight()
    ) - offset;

    const boxBottom = boxTop + box.clientHeight;
    
    return boxTop <= viewBottom && boxBottom >= viewTop;
  };

  const sync = () => {
    if (typeof window === 'undefined') return;
    
    const elements = document.getElementsByClassName(mergedConfig.boxClass);
    boxes.current = Array.from(elements);
    
    boxes.current.forEach(box => {
      if (!box.getAttribute('data-wow-initialized')) {
        box.setAttribute('data-wow-initialized', 'true');
        if (isVisible(box)) {
          show(box);
        }
      }
    });
  };

  const show = (box) => {
    box.style.visibility = 'visible';
    
    const duration = box.getAttribute('data-wow-duration');
    const delay = box.getAttribute('data-wow-delay');
    const iteration = box.getAttribute('data-wow-iteration');

    if (duration) {
      box.style.animationDuration = duration;
    }
    if (delay) {
      box.style.animationDelay = delay;
    }
    if (iteration) {
      box.style.animationIterationCount = iteration;
    }

    box.classList.add(mergedConfig.animateClass);

    if (mergedConfig.callback) {
      mergedConfig.callback(box);
    }

    const resetAnimation = (event) => {
      if (event.type.toLowerCase().indexOf('animationend') >= 0) {
        box.classList.remove(mergedConfig.animateClass);
      }
    };

    ['animationend', 'oanimationend', 'webkitAnimationEnd', 'MSAnimationEnd'].forEach(event => {
      box.addEventListener(event, resetAnimation);
    });
  };

  const scrollHandler = () => {
    scrolled.current = true;
  };

  const scrollCallback = () => {
    if (!scrolled.current) return;
    
    scrolled.current = false;
    
    boxes.current = boxes.current.filter(box => {
      if (!box || isVisible(box)) {
        if (box) show(box);
        return false;
      }
      return true;
    });

    if (!boxes.current.length && !mergedConfig.live) {
      // Stop watching for new elements
      cleanup();
    }
  };

  const cleanup = () => {
    if (typeof window === 'undefined') return;
    
    if (interval.current) {
      clearInterval(interval.current);
      interval.current = null;
    }

    if (mergedConfig.scrollContainer) {
      util.removeEvent(mergedConfig.scrollContainer, 'scroll', scrollHandler);
    } else {
      util.removeEvent(window, 'scroll', scrollHandler);
    }

    util.removeEvent(window, 'resize', scrollHandler);
  };

  useEffect(() => {
    if (typeof window === 'undefined') return;
    
    if (!mergedConfig.mobile && util.isMobile(navigator.userAgent)) {
      return;
    }

    // Initial sync
    sync();

    // Set up scroll and resize handlers
    util.addEvent(
      mergedConfig.scrollContainer || window,
      'scroll',
      scrollHandler
    );
    util.addEvent(window, 'resize', scrollHandler);
    
    // Start the animation check interval
    interval.current = setInterval(scrollCallback, 50);

    // Set up MutationObserver for live mode
    if (mergedConfig.live && typeof MutationObserver !== 'undefined') {
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          Array.from(mutation.addedNodes).forEach((node) => {
            if (node.nodeType === 1) {
              sync();
            }
          });
        });
      });

      observer.observe(document.body, {
        childList: true,
        subtree: true,
      });
    }

    return cleanup;
  }, [mergedConfig.mobile, mergedConfig.scrollContainer, mergedConfig.live]);

  return {
    sync,
    boxes: boxes.current,
  };
};

export default useWowAnimation;